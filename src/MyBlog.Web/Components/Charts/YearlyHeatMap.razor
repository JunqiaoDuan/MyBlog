@using MyBlog.Service.Shared.Dtos.VisualDto
@using Plotly.Blazor
﻿@using Plotly.Blazor.LayoutLib
@using Plotly.Blazor.LayoutLib.XAxisLib
@using System.Globalization
@using Plotly.Blazor.Traces

<div style="height:320px; min-height:320px; width:600px;">
    <PlotlyChart style="height:100%; width:100%;" @bind-Config="config" @bind-Layout="layout" @bind-Data="data" @ref="chart" />
</div>

@code {

    [Parameter]
    public IEnumerable<DateIntValue>? DataList { get; set; }

    private PlotlyChart? chart;
    private Config? config;
    private Layout? layout;
    private IList<ITrace>? data;

    const int RowCount = 14;

    protected override void OnInitialized()
    {
        config = new Config
        {
            ShowLink = false,
            Responsive = true,
            DisplayLogo = false,
        };

        layout = new Layout
        {
            Title = new Plotly.Blazor.LayoutLib.Title { Text = "Pomodoro Duration" },
            XAxis = new List<XAxis>
            {
                new XAxis
                {
                    Side = SideEnum.Top,
                    TickAngle = 0,
                }
            },
            YAxis = new List<YAxis>
            {
                new YAxis
                {
                }
            },
            Height = 320,
            Width = 600
        };

        data = GetMapData().ToList();

        base.OnInitialized();
    }

    private IList<ITrace> GetMapData()
    {
        #region process data

        var workData = new List<DateIntValue>();
        if (DataList != null)
        {
            workData = DataList
                .OrderBy(i => i.Date)
                .ToList();
        }

        parseDataList(workData, out Dictionary<DateTime, int> workDataDic, out DateTime startDay, out DateTime endDay, out int durationDay);

        #endregion

        #region cal matrix

        var rowCount = RowCount;
        var coulmnCount = (int)Math.Ceiling(durationDay / (decimal)rowCount);

        // init matrix
        var valueMatrix = new double?[rowCount][];
        var dateMatrix = new DateTime[rowCount][];
        for (int i = 0; i < rowCount; i++)
        {
            valueMatrix[i] = new double?[coulmnCount];
            dateMatrix[i] = new DateTime[coulmnCount];
        }

        // fill matrix
        for (int idx = 0; idx < durationDay; idx++)
        {
            var _currDate = startDay.AddDays((double)idx);
            var _currDateString = FormatDateToString(_currDate);

            if (!workDataDic.ContainsKey(_currDate))
            {
                continue;
            }
            var _workData = workDataDic[_currDate];

            var rowIdx = rowCount - 1 - (int)(idx % rowCount);  // reverse top-down
            var columnIdx = (int)(idx / rowCount);

            valueMatrix[rowIdx][columnIdx] = _workData;
            dateMatrix[rowIdx][columnIdx] = _currDate;
        }

        #endregion

        #region prepare data for plotly
        var random = new Random();
        var xLabels = dateMatrix[0]
            .Select(i => getMonthNames(i))
            .Select(i => $"{i}.{random.NextInt64(0, 999)}")
            .ToList();

        var dayNamesOfWeek = getDayNamesOfWeekStartingFrom(startDay);
        var yLabels = new List<string>();
        yLabels.AddRange(dayNamesOfWeek);
        yLabels.AddRange(dayNamesOfWeek.Select(i => $"{i}."));
        yLabels.Reverse();

        var customData = new List<List<string>>();
        for (int i = 0; i < dateMatrix.Length; i++)
        {
            customData.Add(dateMatrix[i].Select(i => FormatDateToString(i)).ToList());
        }

        #endregion

        return new List<ITrace>
        {
            new HeatMap
            {
                X = xLabels.Cast<object>().ToList(),
                Y = yLabels.Cast<object>().ToList(),
                Z = valueMatrix.Cast<object>().ToList(),
                CustomData = customData.Cast<object>().ToList(),
                ColorScale = new[]
                {
                    new[] { "0", "#ebedf0" },
                    new[] { "0.1", "#9be9a8" },
                    new[] { "0.5", "#40c463" },
                    new[] { "1", "#216e39" }
                },
                HoverTemplate = "%{customdata} %{z}<extra></extra>min",
                ShowScale = true,
                XGap = 2, // horizontal padding between cells (in px)
                YGap = 2  // vertical padding between cells (in px)
            }
        };
    }

    private void parseDataList(
        List<DateIntValue> dateValues,
        out Dictionary<DateTime, int> dateValuesDic,
        out DateTime startDay,
        out DateTime endDay,
        out int durationDay)
    {
        dateValuesDic = new Dictionary<DateTime, int>();

        if (dateValues == null || dateValues.Count == 0)
        {
            startDay = endDay = DateTime.MinValue;
            durationDay = 0;
            return;
        }

        var ordered = dateValues
            .OrderBy(d => d.Date)
            .ToList();

        startDay = ParseDateString(ordered.First().Date);
        endDay = ParseDateString(ordered.Last().Date);
        durationDay = (endDay - startDay).Days + 1;

        foreach (var item in dateValues)
        {
            var date = ParseDateString(item.Date);
            if (!dateValuesDic.ContainsKey(date))
            {
                dateValuesDic.Add(date, item.Value);
            }
        }
    }

    private List<string> getDayNamesOfWeekStartingFrom(DateTime startDate)
    {
        var dayNames = new List<string>();
        for (int i = 0; i < 7; i++)
        {
            var day = startDate.AddDays(i);
            dayNames.Add(day.ToString("ddd", CultureInfo.InvariantCulture));
        }
        return dayNames;
    }

    private string getMonthNames(DateTime date)
    {
        return date.ToString("MMM", CultureInfo.InvariantCulture);
    }

    private DateTime ParseDateString(string dateString)
    {
        return DateTime.ParseExact(dateString, "yyyyMMdd", CultureInfo.InvariantCulture);
    }

    private string FormatDateToString(DateTime date)
    {
        return date.ToString("yyyyMMdd", CultureInfo.InvariantCulture);
    }

}